/*
   (C) 2014 Florian Huemer

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>

   This scanner based on the scanner of the VAUL/freehdl project
   (V0.0.7 http://www.freehdl.seul.org/).
   
   Original copyright holders:
   
   Copyright (C) 1993, 2003 Universite Pierre et Marie Curie (PARIS VI)
   MASI/CAO-VLSI CAD Team

   Copyright (C) Thomas Dettmer

   Copyright (C) 1994-1997 University of Dortmund
   Department of Electrical Engineering, AG SIV
*/

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser.tab.h"  /* Generated by bison. */
#include "parser_error.h"
#include "linked_list.h"

/* --[^\n]*          {} */

extern struct ll_node *error_list;

/* handle locations */
uint32_t yycolumn = 1;
uint32_t yytextposition = 0;


#define YY_USER_ACTION               \
	do{                                \
		yylloc->first_line   = yylineno; \
		yylloc->last_line    = yylineno; \
		yylloc->first_column = yycolumn; \
		yylloc->last_column  = yycolumn+yyleng-1;   \
		yylloc->start_position = yytextposition;    \
		yylloc->end_position   = yytextposition+yyleng-1;    \
		yytextposition += yyleng; \
	}while(0); 


void reset_scanner(FILE* file)
{
	YY_FLUSH_BUFFER;
	yyrestart(file);
}

%}


%option bison-bridge bison-locations noyywrap 
%option yylineno

IDENTIFIER    [A-Za-z](_?[A-Za-z0-9])*


upper_case_letter	[A-Z]
digit			[0-9]
special_char		[\#\&\'\(\)\*\+\,\-\.\/\:\;\<\=\>\_\|]
space_char		[ \t]
format_effector		[\t\v\r\f]
end_of_line		\n
lower_case_letter	[a-z]
other_special_char	[\!\$\@\?\[\\\]\^\`\{\}\~]

graphic_char         {basic_graphic_char}|{lower_case_letter}|{other_special_char}
basic_graphic_char   {upper_case_letter}|{digit}|{special_char}|{space_char}
letter               {upper_case_letter}|{lower_case_letter}
letter_or_u          {letter}|\_
letter_or_digit      {letter}|{digit}
letter_or_u_or_digit {letter_or_u}|{digit}
decimal_literal	     {integer}(\.{integer})?({exponent})?
integer              {digit}(_?{digit})*
exponent             [eE][-+]?{integer}
base                 {integer}
based_integer        {extended_digit}(_?{extended_digit})*
extended_digit       {digit}|[a-fA-F]
base_specifier       (B|b|O|o|X|x)
%%

(?i:abs)           { return t_ABS;}
(?i:access)        { return t_ACCESS;}
(?i:after)         { return t_AFTER;}
(?i:and)           { return t_AND;}
(?i:alias)         { return t_ALIAS;}
(?i:all)           { return t_ALL;}
(?i:architecture)  { return t_ARCHITECTURE;}
(?i:array)         { return t_ARRAY;}
(?i:assert)        { return t_ASSERT;}
(?i:attribute)     { return t_ATTRIBUTE;}
(?i:begin)         { return t_BEGIN;}
(?i:block)         { return t_BLOCK; }
(?i:body)          { return t_BODY; }
(?i:buffer)        { return t_BUFFER; }
(?i:bus)           { return t_BUS; }
(?i:case)          { return t_CASE;}
(?i:component)     { return t_COMPONENT;}
(?i:configuration) { return t_CONFIGURATION;}
(?i:constant)      { return t_CONSTANT;}
(?i:disconnect)    { return t_DISCONNECT;}
(?i:downto)        { return t_DOWNTO;}
(?i:else)          { return t_ELSE;}
(?i:elsif)         { return t_ELSIF;}
(?i:end)           { return t_END;}
(?i:entity)        { return t_ENTITY;}
(?i:exit)          { return t_EXIT; }
(?i:file)          { return t_FILE; }
(?i:for)           { return t_FOR;}
(?i:function)      { return t_FUNCTION;}
(?i:generate)      { return t_GENERATE; }
(?i:generic)       { return t_GENERIC;}
(?i:guarded)       { return t_GUARDED;}
(?i:if)            { return t_IF;}
(?i:impure)        { return t_IMPURE;}
(?i:inout)         { return t_INOUT;}
(?i:in)            { return t_IN;}
(?i:inertial)      { return t_INERTIAL;}
(?i:is)            { return t_IS;}
(?i:label)         { return t_LABEL;}
(?i:library)       { return t_LIBRARY; }
(?i:linkage)       { return t_LINKAGE; }
(?i:loop)          { return t_LOOP;}
(?i:map)           { return t_MAP; }
(?i:mod)           { return t_MOD; }
(?i:nand)          { return t_NAND;}
(?i:new)           { return t_NEW;}
(?i:next)          { return t_NEXT;}
(?i:nor)           { return t_NOR;}
(?i:not)           { return t_NOT;}
(?i:null)          { return t_NULL;}
(?i:of)            { return t_OF;}
(?i:on)            { return t_ON;}
(?i:open)          { return t_OPEN;}
(?i:or)            { return t_OR;}
(?i:others)        { return t_OTHERS;}
(?i:out)           { return t_OUT;}
(?i:package)       { return t_PACKAGE;}
(?i:port)          { return t_PORT;}
(?i:postponed)     { return t_POSTPONED;}
(?i:procedure)     { return t_PROCEDURE;}
(?i:process)       { return t_PROCESS; }
(?i:pure)          { return t_PURE;}
(?i:range)         { return t_RANGE;}
(?i:record)        { return t_RECORD;}
(?i:register)      { return t_REGISTER;}
(?i:reject)        { return t_REJECT;}
(?i:rem)           { return t_REM;}
(?i:report)        { return t_REPORT; }
(?i:return)        { return t_RETURN;}
(?i:reverse_range) { return t_REVERSE_RANGE;}
(?i:rol)           { return t_ROL;}
(?i:ror)           { return t_ROR;}
(?i:select)        { return t_SELECT;}
(?i:severity)      { return t_SEVERITY;}
(?i:shared)        { return t_SHARED;}
(?i:signal)        { return t_SIGNAL;}
(?i:sla)           { return t_SLA;}
(?i:sll)           { return t_SLL;}
(?i:sra)           { return t_SRA;}
(?i:srl)           { return t_SRL;}
(?i:subtype)       { return t_SUBTYPE;}
(?i:then)          { return t_THEN;}
(?i:to)            { return t_TO;}
(?i:transport)     { return t_TRANSPORT;}
(?i:type)          { return t_TYPE;}
(?i:units)         { return t_UNITS; }
(?i:until)         { return t_UNTIL; }
(?i:use)           { return t_USE; }
(?i:variable)      { return t_VARIABLE;}
(?i:wait)          { return t_WAIT;}
(?i:when)          { return t_WHEN;}
(?i:while)         { return t_WHILE;}
(?i:with)          { return t_WITH;}
(?i:xnor)          { return t_XNOR;}
(?i:xor)           { return t_XOR;}


{space_char}        /* nothing */
{format_effector}   /* still nothing */

\&                 { return t_Ampersand; }
\'                 { return t_Apostrophe; }
\(                 { return t_LeftParen;}
\)                 { return t_RightParen;}
"**"               { return t_DoubleStar;}
\*                 { return t_Star;}
\+                 { return t_Plus;}
\,                 { return t_Comma;}
\-                 { return t_Minus;}
":="               { return t_VarAsgn; }
\:                 { return t_Colon; }
\;                 { return t_Semicolon;}
"<="               { return t_LESym;}
">="               { return t_GESym;}
\<                 { return t_LTSym;}
\>                 { return t_GTSym;}
\=                 { return t_EQSym;}
"/="               { return t_NESym;}
"=>"               { return t_Arrow;}
"<>"               { return t_Box;}
\|                 { return t_Bar;}
!                  { return t_Bar;}
\.                 { return t_Dot;}
\/                 { return t_Slash;}

\n                 { yycolumn = 1; }


{letter_or_u}(_?{letter_or_u_or_digit})* {
	yylval->str = (char*)strdup(yytext);
	if (yytext[0] == '_' || yytext[yyleng-1] == '_' )
	{
		struct parser_error *err = (struct parser_error *)create_error_id(yylineno, ERROR_UNDERSCORE);
		error_list = ll_append_back(error_list, err);
	}
	return t_Identifier;
}


{decimal_literal}|({base}#{based_integer}(\.{based_integer})?#{exponent}?)|({base}:{based_integer}(\.{based_integer})?:{exponent}?)	{return t_AbstractLit;}


'({graphic_char}|\"|\%)'    { return t_CharacterLit; }

(\"({graphic_char}|(\"\")|\%)*\")|(\%({graphic_char}|(\%\%)|\")*\%) { 	yylval->str = (char*)strdup(yytext); return t_StringLit; }

{base_specifier}(\"{extended_digit}(_?{extended_digit})*\"|\%{extended_digit}(_?{extended_digit})*\%)  { return t_StringLit; }


\-\-.*$    {/* comment */}


. { 
		struct parser_error_1c *err = create_error_illegal_symbol(yylineno, yytext[0]); 
		error_list = ll_append_back(error_list, err);
  }
 
